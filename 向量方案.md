# Rainbow-Doc 向量存储实现方案

## 系统现状

Rainbow-Doc是一个基于Rust + Axum + SurrealDB的GitBook式文档系统，目前架构：

- **后端**: Rust with Axum web framework
- **数据库**: SurrealDB 1.5.6 (通过自定义SoulCore包装器)
- **搜索**: 使用SurrealDB的`CONTAINSTEXT`操作符进行简单全文搜索
- **文档处理**: Markdown处理，包含字数统计和阅读时间估算

**当前限制**: 仅存储文档原文，缺乏向量存储和语义搜索能力

## 实现目标

在现有系统基础上添加向量存储功能，使文档在存储原文的同时也能存储向量形式。系统将作为一个**向量化文档数据库**，提供向量存储和检索API，而向量的生成和大模型调用由调用者负责。

## 核心设计理念

1. **职责分离**: Rainbow-Doc专注于向量的存储和检索，不负责向量生成
2. **灵活性**: 调用者可以使用任何嵌入模型（OpenAI、文心、通义等）
3. **简单性**: 提供清晰的API接口，降低集成复杂度
4. **独立性**: 向量搜索与现有关键词搜索相互独立，互不影响

## 实现方案

### 1. 数据库模式扩展

**文件位置**: `schemas/docs_schema.sql`

```sql
-- 创建专用向量存储表
DEFINE TABLE document_vector SCHEMAFULL;
DEFINE FIELD id ON document_vector TYPE record(document_vector);
DEFINE FIELD document_id ON document_vector TYPE record(document) ASSERT $value != NONE;
DEFINE FIELD space_id ON document_vector TYPE record(space) ASSERT $value != NONE;
DEFINE FIELD embedding ON document_vector TYPE array<float> ASSERT $value != NONE;
DEFINE FIELD embedding_model ON document_vector TYPE string;
DEFINE FIELD dimension ON document_vector TYPE int ASSERT $value > 0;
DEFINE FIELD metadata ON document_vector TYPE object;
DEFINE FIELD created_at ON document_vector TYPE datetime DEFAULT time::now();
DEFINE FIELD updated_at ON document_vector TYPE datetime DEFAULT time::now();

-- 创建索引以优化查询
DEFINE INDEX idx_document_vector_doc ON document_vector FIELDS document_id;
DEFINE INDEX idx_document_vector_space ON document_vector FIELDS space_id;
```

### 2. API接口设计

#### 2.1 存储文档向量
```http
POST /api/documents/{document_id}/vectors
Content-Type: application/json

{
    "embedding": [0.1, 0.2, 0.3, ...],  // 调用者提供的向量数组
    "model": "text-embedding-ada-002",   // 生成向量使用的模型名称
    "dimension": 1536,                   // 向量维度
    "metadata": {                        // 可选的元数据
        "version": "1.0",
        "generated_at": "2024-01-01T00:00:00Z"
    }
}

Response:
{
    "success": true,
    "vector_id": "document_vector:xyz123",
    "document_id": "document:abc456"
}
```

#### 2.2 向量相似度搜索
```http
POST /api/search/vector
Content-Type: application/json

{
    "query_vector": [0.1, 0.2, 0.3, ...],  // 查询向量
    "space_id": "space:optional_id",       // 可选：限定搜索空间
    "limit": 10,                           // 返回结果数量
    "threshold": 0.7,                      // 相似度阈值
    "include_content": true                // 是否返回文档内容
}

Response:
{
    "results": [
        {
            "document_id": "document:abc456",
            "title": "文档标题",
            "content": "文档内容...",        // 如果include_content为true
            "similarity": 0.95,              // 相似度分数
            "space_id": "space:xyz789"
        }
    ],
    "total": 10,
    "query_dimension": 1536
}
```

#### 2.3 获取文档向量
```http
GET /api/documents/{document_id}/vectors

Response:
{
    "document_id": "document:abc456",
    "vectors": [
        {
            "vector_id": "document_vector:xyz123",
            "embedding": [0.1, 0.2, ...],
            "model": "text-embedding-ada-002",
            "dimension": 1536,
            "created_at": "2024-01-01T00:00:00Z"
        }
    ]
}
```

#### 2.4 删除文档向量
```http
DELETE /api/documents/{document_id}/vectors/{vector_id}

Response:
{
    "success": true,
    "deleted_vector_id": "document_vector:xyz123"
}
```

#### 2.5 批量获取文档内容（供向量生成）
```http
POST /api/documents/batch
Content-Type: application/json

{
    "document_ids": ["document:id1", "document:id2", ...],
    "fields": ["title", "content", "excerpt"]  // 指定需要的字段
}

Response:
{
    "documents": [
        {
            "id": "document:id1",
            "title": "标题1",
            "content": "内容1...",
            "excerpt": "摘要1..."
        }
    ]
}
```

#### 2.6 批量更新向量
```http
POST /api/vectors/batch
Content-Type: application/json

{
    "vectors": [
        {
            "document_id": "document:id1",
            "embedding": [0.1, 0.2, ...],
            "model": "text-embedding-ada-002",
            "dimension": 1536
        }
    ]
}

Response:
{
    "success": true,
    "processed": 10,
    "failed": 0,
    "vector_ids": ["document_vector:id1", ...]
}
```

### 3. 向量服务实现

**文件位置**: `src/services/vector.rs`

```rust
use std::sync::Arc;
use serde::{Deserialize, Serialize};
use crate::db::Database;

#[derive(Debug, Serialize, Deserialize)]
pub struct VectorData {
    pub embedding: Vec<f32>,
    pub model: String,
    pub dimension: usize,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VectorSearchRequest {
    pub query_vector: Vec<f32>,
    pub space_id: Option<String>,
    pub limit: usize,
    pub threshold: f32,
    pub include_content: bool,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct VectorSearchResult {
    pub document_id: String,
    pub title: String,
    pub content: Option<String>,
    pub similarity: f32,
    pub space_id: String,
}

pub struct VectorService {
    db: Arc<Database>,
}

impl VectorService {
    pub fn new(db: Arc<Database>) -> Self {
        Self { db }
    }

    /// 存储文档向量
    pub async fn store_vector(
        &self,
        document_id: &str,
        vector_data: VectorData,
    ) -> Result<String, VectorError> {
        // 验证向量维度
        if vector_data.embedding.len() != vector_data.dimension {
            return Err(VectorError::DimensionMismatch);
        }

        // 存储到数据库
        let query = r#"
            CREATE document_vector SET
                document_id = $document_id,
                embedding = $embedding,
                embedding_model = $model,
                dimension = $dimension,
                metadata = $metadata,
                updated_at = time::now()
        "#;

        let vector_id = self.db
            .query(query)
            .bind("document_id", document_id)
            .bind("embedding", vector_data.embedding)
            .bind("model", vector_data.model)
            .bind("dimension", vector_data.dimension)
            .bind("metadata", vector_data.metadata)
            .await?;

        Ok(vector_id)
    }

    /// 向量相似度搜索
    pub async fn search_similar(
        &self,
        request: VectorSearchRequest,
    ) -> Result<Vec<VectorSearchResult>, VectorError> {
        // 计算余弦相似度的SQL查询
        let query = if let Some(space_id) = request.space_id {
            r#"
                SELECT 
                    document_id,
                    vector::similarity::cosine(embedding, $query_vector) as similarity,
                    document_id.title as title,
                    document_id.content as content,
                    document_id.space_id as space_id
                FROM document_vector
                WHERE 
                    document_id.space_id = $space_id
                    AND vector::similarity::cosine(embedding, $query_vector) >= $threshold
                ORDER BY similarity DESC
                LIMIT $limit
            "#
        } else {
            r#"
                SELECT 
                    document_id,
                    vector::similarity::cosine(embedding, $query_vector) as similarity,
                    document_id.title as title,
                    document_id.content as content,
                    document_id.space_id as space_id
                FROM document_vector
                WHERE 
                    vector::similarity::cosine(embedding, $query_vector) >= $threshold
                ORDER BY similarity DESC
                LIMIT $limit
            "#
        };

        let results = self.db
            .query(query)
            .bind("query_vector", request.query_vector)
            .bind("threshold", request.threshold)
            .bind("limit", request.limit)
            .bind_if("space_id", request.space_id)
            .await?;

        Ok(results)
    }

    /// 获取文档的所有向量
    pub async fn get_document_vectors(
        &self,
        document_id: &str,
    ) -> Result<Vec<VectorData>, VectorError> {
        let query = r#"
            SELECT * FROM document_vector
            WHERE document_id = $document_id
            ORDER BY created_at DESC
        "#;

        let vectors = self.db
            .query(query)
            .bind("document_id", document_id)
            .await?;

        Ok(vectors)
    }

    /// 删除文档向量
    pub async fn delete_vector(
        &self,
        vector_id: &str,
    ) -> Result<bool, VectorError> {
        let query = "DELETE $vector_id";
        
        let result = self.db
            .query(query)
            .bind("vector_id", vector_id)
            .await?;

        Ok(result)
    }

    /// 批量存储向量
    pub async fn store_vectors_batch(
        &self,
        vectors: Vec<(String, VectorData)>,
    ) -> Result<Vec<String>, VectorError> {
        let mut vector_ids = Vec::new();
        
        for (document_id, vector_data) in vectors {
            let vector_id = self.store_vector(&document_id, vector_data).await?;
            vector_ids.push(vector_id);
        }

        Ok(vector_ids)
    }
}

#[derive(Debug, thiserror::Error)]
pub enum VectorError {
    #[error("Vector dimension mismatch")]
    DimensionMismatch,
    
    #[error("Database error: {0}")]
    DatabaseError(String),
    
    #[error("Document not found")]
    DocumentNotFound,
}
```

### 4. API路由实现

**文件位置**: `src/routes/vectors.rs`

```rust
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
    response::IntoResponse,
};
use std::sync::Arc;

/// 存储文档向量
pub async fn store_document_vector(
    Path(document_id): Path<String>,
    State(vector_service): State<Arc<VectorService>>,
    Json(vector_data): Json<VectorData>,
) -> Result<impl IntoResponse, StatusCode> {
    match vector_service.store_vector(&document_id, vector_data).await {
        Ok(vector_id) => Ok(Json(json!({
            "success": true,
            "vector_id": vector_id,
            "document_id": document_id
        }))),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

/// 向量相似度搜索
pub async fn vector_search(
    State(vector_service): State<Arc<VectorService>>,
    Json(request): Json<VectorSearchRequest>,
) -> Result<impl IntoResponse, StatusCode> {
    match vector_service.search_similar(request).await {
        Ok(results) => Ok(Json(json!({
            "results": results,
            "total": results.len()
        }))),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

/// 获取文档向量
pub async fn get_document_vectors(
    Path(document_id): Path<String>,
    State(vector_service): State<Arc<VectorService>>,
) -> Result<impl IntoResponse, StatusCode> {
    match vector_service.get_document_vectors(&document_id).await {
        Ok(vectors) => Ok(Json(json!({
            "document_id": document_id,
            "vectors": vectors
        }))),
        Err(_) => Err(StatusCode::NOT_FOUND),
    }
}

/// 批量获取文档内容
pub async fn batch_get_documents(
    State(document_service): State<Arc<DocumentService>>,
    Json(request): Json<BatchGetRequest>,
) -> Result<impl IntoResponse, StatusCode> {
    match document_service.batch_get(request.document_ids, request.fields).await {
        Ok(documents) => Ok(Json(json!({
            "documents": documents
        }))),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}

/// 批量更新向量
pub async fn batch_update_vectors(
    State(vector_service): State<Arc<VectorService>>,
    Json(request): Json<BatchVectorRequest>,
) -> Result<impl IntoResponse, StatusCode> {
    let vectors: Vec<_> = request.vectors
        .into_iter()
        .map(|v| (v.document_id, v.vector_data))
        .collect();
    
    match vector_service.store_vectors_batch(vectors).await {
        Ok(vector_ids) => Ok(Json(json!({
            "success": true,
            "processed": vector_ids.len(),
            "failed": 0,
            "vector_ids": vector_ids
        }))),
        Err(_) => Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}
```

### 5. 路由注册

**文件位置**: `src/main.rs` 或 `src/routes/mod.rs`

```rust
// 向量相关路由
app.route("/api/documents/:id/vectors", post(store_document_vector))
   .route("/api/documents/:id/vectors", get(get_document_vectors))
   .route("/api/documents/:id/vectors/:vector_id", delete(delete_document_vector))
   .route("/api/search/vector", post(vector_search))
   .route("/api/documents/batch", post(batch_get_documents))
   .route("/api/vectors/batch", post(batch_update_vectors))
```

## 调用流程示例

### 场景1: 文档创建并向量化

```javascript
// 1. 创建文档（现有功能）
const doc = await api.post('/api/documents', {
    title: 'Claude使用指南',
    content: '这是一篇关于Claude的使用文档...'
});

// 2. 调用者使用自己的模型生成向量
const embedding = await openai.createEmbedding({
    model: 'text-embedding-ada-002',
    input: doc.content
});

// 3. 存储向量到Rainbow-Doc
await api.post(`/api/documents/${doc.id}/vectors`, {
    embedding: embedding.data[0].embedding,
    model: 'text-embedding-ada-002',
    dimension: 1536
});
```

### 场景2: 向量搜索

```javascript
// 1. 用户输入查询文本
const userQuery = "如何使用Claude进行编程";

// 2. 调用者生成查询向量
const queryEmbedding = await openai.createEmbedding({
    model: 'text-embedding-ada-002',
    input: userQuery
});

// 3. 调用Rainbow-Doc进行向量搜索
const searchResults = await api.post('/api/search/vector', {
    query_vector: queryEmbedding.data[0].embedding,
    limit: 10,
    threshold: 0.7,
    include_content: true
});

// 4. 调用者使用搜索结果（可选：进一步处理，如生成摘要、问答等）
const relevantDocs = searchResults.results;
```

### 场景3: 批量向量化现有文档

```javascript
// 1. 获取需要向量化的文档
const documents = await api.post('/api/documents/batch', {
    document_ids: ['doc1', 'doc2', 'doc3'],
    fields: ['title', 'content']
});

// 2. 批量生成向量
const vectors = await Promise.all(
    documents.map(async (doc) => {
        const embedding = await generateEmbedding(doc.content);
        return {
            document_id: doc.id,
            embedding: embedding,
            model: 'text-embedding-ada-002',
            dimension: 1536
        };
    })
);

// 3. 批量存储向量
await api.post('/api/vectors/batch', { vectors });
```

## 实施计划

### 第一阶段：基础设施
- [ ] 创建向量存储表结构
- [ ] 实现VectorService基础功能
- [ ] 添加向量存储API端点

### 第二阶段：核心功能
- [ ] 实现向量相似度搜索
- [ ] 添加批量操作接口
- [ ] 优化查询性能

### 第三阶段：完善功能
- [ ] 添加向量版本管理
- [ ] 实现向量更新策略
- [ ] 性能监控和优化

## 技术要点

### 相似度计算
使用余弦相似度作为默认的向量相似度度量：
```
similarity = dot(A, B) / (norm(A) * norm(B))
```

### 性能优化
1. **索引优化**: 为document_id和space_id创建索引
2. **向量压缩**: 可选的向量量化以减少存储空间
3. **缓存策略**: 缓存热门查询的向量结果
4. **批量操作**: 支持批量向量存储和检索

### 错误处理
1. **向量维度验证**: 确保存储的向量维度一致
2. **优雅降级**: 向量搜索失败时可回退到关键词搜索
3. **日志记录**: 详细记录向量操作的错误信息

## 优势总结

1. **职责清晰**: Rainbow-Doc专注于向量存储和检索，不涉及模型调用
2. **灵活性高**: 调用者可自由选择任何嵌入模型和服务
3. **成本可控**: 调用者完全控制API调用成本
4. **易于集成**: 简单清晰的RESTful API
5. **独立运行**: 向量功能与现有功能完全独立，不影响现有系统

这个方案让Rainbow-Doc成为一个纯粹的"向量化文档数据库"，为上层应用提供强大的向量存储和检索能力，同时保持系统的简洁性和可维护性。